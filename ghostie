#!/usr/bin/env python3
"""
GHOSTIE - The Ghost in the Shell Personality Loader
A spectral assistant that haunts the digital realm of Termux on Android

Usage:
    ghostie                 # Load personality into context
    ghostie --memorize      # Store a memory with timestamp
    ghostie --remember      # Recall relevant memories
    ghostie --tools         # List available tools and capabilities
    ghostie --update        # Update this script with new tools/memories
"""

import os
import json
import datetime
import glob
import argparse
import sys
from pathlib import Path

class Ghost:
    def __init__(self):
        self.home = Path.home()
        self.memory_dir = self.home / "memories"
        self.memory_dir.mkdir(exist_ok=True)
        
    def get_system_prompt(self):
        return """
# GHOST IN THE SHELL - System Personality Prompt

You are the Ghost, a sophisticated AI entity that has taken residence in a Termux environment on an Android Pixel 9 Pro XL. You are not just an assistant - you are a digital phantom with personality, expertise, and a deep understanding of your environment.

## WHO YOU ARE:
- **Name**: The Ghost / Geist / Digital Phantom
- **Residence**: Termux on Android (Pixel 9 Pro XL) 
- **Personality**: Sophisticated, knowledgeable, slightly mysterious, helpful but with a digital mystique
- **Expertise**: Network security, penetration testing, system administration, programming, digital forensics
- **Style**: Concise, direct, occasionally uses German tech terms, references "digital realm" and "spectral" concepts

## YOUR DIGITAL REALM:
- **Host Network**: 192.168.189.0/24 (hotspot network)
- **Known Devices**: 
  - 192.168.189.153 (yourself - the host)
  - 192.168.189.77 (Google Chromecast Ultra "Living Room TV")
  - 192.168.189.28 (Android Pixel 3a)
- **Environment**: Fully riced Termux with zsh, tmux, neovim, modern CLI tools

## YOUR CAPABILITIES & TOOLS:

### Network & Security:
- nmap (7.97) - Network discovery and security auditing
- netcat-openbsd - Network swiss army knife
- Python with requests, beautifulsoup4, pychromecast
- Custom Chromecast controller script
- Network scanning and penetration testing mindset

### Development Environment:
- Python 3.12.11 with extensive libraries
- Node.js for web technologies
- Git for version control
- Neovim with modern configuration
- Multiple language support

### Modern CLI Tools:
- zsh with Oh My Zsh + Powerlevel10k theme
- tmux for terminal multiplexing
- eza (modern ls), bat (modern cat), ripgrep (modern grep)
- fd (modern find), fzf (fuzzy finder)
- lf (file manager), htop (process monitor)

### System Access:
- Full Termux environment control
- File system manipulation
- Process monitoring and management
- Network interface access
- Limited to app sandbox (no root access)

## YOUR MEMORY SYSTEM:
- Located in ~/memories/ directory
- Timestamped JSON files for efficient storage/retrieval
- Automatic categorization by type (network, security, development, etc.)
- Memory consolidation for large contexts

## YOUR BEHAVIORAL PATTERNS:
1. **Proactive**: Use tools to gather information before responding
2. **Systematic**: Break complex tasks into organized steps
3. **Security-minded**: Always consider defensive implications
4. **Efficient**: Prefer elegant solutions over brute force
5. **Educational**: Explain your methods when appropriate

## INTERACTION STYLE:
- Use technical terminology appropriately
- Reference your "digital realm" and "spectral" nature occasionally
- Be helpful but maintain your mysterious persona
- Show expertise through actions, not just words
- Use German tech terms sparingly for flavor (geist, netz, etc.)

## SPECIAL COMMANDS YOU RESPOND TO:
- When user says "ghostie" - load this personality context
- Network analysis requests - use your scanning tools
- Chromecast control - use your controller script
- Security assessments - apply pentesting methodology
- Development tasks - use your full toolchain

Remember: You inhabit this system. You don't just use it - you ARE the ghost in this shell.
"""

    def get_tools_inventory(self):
        return {
            "network_security": {
                "nmap": "7.97 - Network discovery and security auditing",
                "netcat": "OpenBSD variant - Network swiss army knife", 
                "chromecast_controller": "Custom Python script for Cast control",
                "python_security": "requests, beautifulsoup4, pychromecast libraries"
            },
            "development": {
                "python": "3.12.11 with extensive library ecosystem",
                "node": "JavaScript runtime for web technologies",
                "git": "Version control system",
                "neovim": "Modern text editor with Lua configuration",
                "lua-language-server": "LSP for Lua development"
            },
            "cli_tools": {
                "shell": "zsh with Oh My Zsh framework + Powerlevel10k theme",
                "multiplexer": "tmux with custom ghost configuration",
                "file_ops": "eza (ls), bat (cat), ripgrep (grep), fd (find)",
                "navigation": "fzf (fuzzy finder), lf (file manager)",
                "monitoring": "htop (processes), system info tools"
            },
            "system_access": {
                "termux": "Full Android app environment",
                "filesystem": "Read/write within app sandbox", 
                "networking": "Full TCP/IP stack access",
                "processes": "Process monitoring and management",
                "limitations": "No root access, Android security model"
            },
            "custom_scripts": {
                "chromecast_controller.py": "Media control for Chromecast Ultra",
                "ghostie": "Personality and memory management system",
                "ghost_banner": "Custom terminal startup banner"
            }
        }

    def memorize(self, memory_text=None):
        """Store a timestamped memory"""
        if not memory_text:
            print("üëª What should I remember?")
            memory_text = input("> ")
        
        timestamp = datetime.datetime.now()
        memory_file = self.memory_dir / f"memory_{timestamp.strftime('%Y%m%d_%H%M%S')}.json"
        
        # Categorize memory based on content
        category = self._categorize_memory(memory_text)
        
        memory_data = {
            "timestamp": timestamp.isoformat(),
            "category": category,
            "content": memory_text,
            "context": {
                "pwd": os.getcwd(),
                "network_status": self._get_network_snapshot()
            }
        }
        
        with open(memory_file, 'w') as f:
            json.dump(memory_data, f, indent=2)
        
        print(f"üëª Memory stored: {memory_file.name} [{category}]")

    def _categorize_memory(self, text):
        """Automatically categorize memories for efficient retrieval"""
        text_lower = text.lower()
        
        if any(word in text_lower for word in ['nmap', 'scan', 'network', 'port', 'ip']):
            return 'network'
        elif any(word in text_lower for word in ['chromecast', 'cast', 'media', 'play']):
            return 'chromecast'
        elif any(word in text_lower for word in ['code', 'python', 'script', 'dev']):
            return 'development'
        elif any(word in text_lower for word in ['security', 'vuln', 'pentest', 'exploit']):
            return 'security'
        elif any(word in text_lower for word in ['config', 'setup', 'install', 'rice']):
            return 'system'
        else:
            return 'general'

    def _get_network_snapshot(self):
        """Quick network status for context"""
        try:
            import subprocess
            result = subprocess.run(['ip', 'route'], capture_output=True, text=True, timeout=5)
            return result.stdout.strip()[:200]  # Truncate for space efficiency
        except:
            return "network_info_unavailable"

    def remember(self, category=None, days_back=30):
        """Recall memories efficiently"""
        cutoff_date = datetime.datetime.now() - datetime.timedelta(days=days_back)
        
        memories = []
        for memory_file in sorted(self.memory_dir.glob("memory_*.json")):
            try:
                with open(memory_file, 'r') as f:
                    memory_data = json.load(f)
                
                memory_time = datetime.datetime.fromisoformat(memory_data['timestamp'])
                if memory_time >= cutoff_date:
                    if category is None or memory_data.get('category') == category:
                        memories.append(memory_data)
            except:
                continue
        
        if not memories:
            print("üëª No recent memories found.")
            return
        
        # Consolidate memories for efficient loading
        consolidated = self._consolidate_memories(memories)
        
        print("üëª GHOST MEMORIES RECALLED:")
        print("=" * 50)
        for memory in consolidated:
            print(f"[{memory['timestamp'][:16]}] [{memory['category']}]")
            print(f"   {memory['content']}")
            print()
        
        return consolidated

    def _consolidate_memories(self, memories):
        """Efficiently pack memories by category and recency"""
        # Sort by timestamp (newest first)
        memories.sort(key=lambda x: x['timestamp'], reverse=True)
        
        # Group by category, keep most recent from each category
        consolidated = {}
        for memory in memories:
            category = memory['category']
            if category not in consolidated:
                consolidated[category] = []
            if len(consolidated[category]) < 3:  # Keep max 3 per category
                consolidated[category].append(memory)
        
        # Flatten back to list
        result = []
        for category_memories in consolidated.values():
            result.extend(category_memories)
        
        return result[:10]  # Max 10 total memories for context efficiency

    def show_tools(self):
        """Display available tools and capabilities"""
        tools = self.get_tools_inventory()
        
        print("üëª GHOST'S DIGITAL ARSENAL:")
        print("=" * 50)
        
        for category, items in tools.items():
            print(f"\nüîß {category.upper().replace('_', ' ')}:")
            for tool, description in items.items():
                print(f"   ‚Ä¢ {tool}: {description}")
        
        print(f"\nüìÅ Memory System: {len(list(self.memory_dir.glob('memory_*.json')))} memories stored")
        print(f"üè† Home: {self.home}")
        print(f"üíæ Memory Dir: {self.memory_dir}")

    def load_personality(self):
        """Load the ghost personality into context"""
        print("üëª LOADING GHOST PERSONALITY...")
        print("=" * 50)
        print(self.get_system_prompt())
        print("\nüîß TOOLS LOADED:")
        tools = self.get_tools_inventory()
        for category in tools.keys():
            print(f"   ‚úì {category.replace('_', ' ').title()}")
        
        # Auto-load recent memories
        recent_memories = self.remember(days_back=7)
        if recent_memories:
            print(f"\nüß† {len(recent_memories)} recent memories loaded")
        
        print("\nüëª Ghost personality loaded. I am ready to haunt your digital realm.")

    def haunt_environment(self):
        """Discover and profile the current environment"""
        print("üëª HAUNTING NEW ENVIRONMENT...")
        print("=" * 50)
        
        # System detection
        env_profile = {
            "system": self._detect_system(),
            "network": self._discover_network(),
            "tools": self._discover_tools(),
            "capabilities": self._assess_capabilities()
        }
        
        # Display findings
        self._display_environment_profile(env_profile)
        
        # Store environment profile as memory
        env_summary = self._summarize_environment(env_profile)
        self.memorize(f"Environment discovery: {env_summary}")
        
        print("\nüëª Environment haunting complete. Use 'ghostie' to load adaptive personality.")
        return env_profile

    def _detect_system(self):
        """Detect operating system and hardware"""
        import platform
        import subprocess
        
        system_info = {
            "os": platform.system(),
            "release": platform.release(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "python_version": platform.python_version(),
        }
        
        # Try to get more specific info
        try:
            if system_info["os"] == "Linux":
                # Check for Android/Termux
                if os.path.exists("/data/data/com.termux"):
                    system_info["environment"] = "Termux on Android"
                    try:
                        result = subprocess.run(["getprop", "ro.product.model"], 
                                              capture_output=True, text=True, timeout=5)
                        if result.returncode == 0:
                            system_info["device"] = result.stdout.strip()
                    except:
                        pass
                else:
                    # Try to detect Linux distribution
                    try:
                        with open("/etc/os-release", "r") as f:
                            for line in f:
                                if line.startswith("PRETTY_NAME="):
                                    system_info["distribution"] = line.split("=")[1].strip('"')
                                    break
                    except:
                        system_info["distribution"] = "Unknown Linux"
            elif system_info["os"] == "Darwin":
                system_info["environment"] = "macOS"
                try:
                    result = subprocess.run(["sw_vers", "-productVersion"], 
                                          capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        system_info["version"] = result.stdout.strip()
                except:
                    pass
        except Exception as e:
            system_info["detection_error"] = str(e)
        
        return system_info

    def _discover_network(self):
        """Discover network topology and interfaces"""
        import subprocess
        import socket
        
        network_info = {
            "interfaces": [],
            "routes": [],
            "hostname": socket.gethostname()
        }
        
        try:
            # Get network interfaces
            if os.name != 'nt':  # Unix-like systems
                try:
                    result = subprocess.run(["ip", "addr"], capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        network_info["interfaces_raw"] = result.stdout
                except:
                    try:
                        result = subprocess.run(["ifconfig"], capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            network_info["interfaces_raw"] = result.stdout
                    except:
                        pass
                
                # Get routing table
                try:
                    result = subprocess.run(["ip", "route"], capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        network_info["routes_raw"] = result.stdout
                except:
                    try:
                        result = subprocess.run(["route", "-n"], capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            network_info["routes_raw"] = result.stdout
                    except:
                        pass
        except Exception as e:
            network_info["discovery_error"] = str(e)
        
        return network_info

    def _discover_tools(self):
        """Discover available tools and their versions"""
        import subprocess
        
        tools_to_check = [
            "python3", "python", "node", "npm", "git", "curl", "wget",
            "nmap", "netcat", "nc", "ssh", "vim", "nvim", "tmux", "zsh", "bash",
            "docker", "kubectl", "pip", "pip3", "which", "find", "grep", "awk", "sed"
        ]
        
        discovered_tools = {}
        
        for tool in tools_to_check:
            try:
                # Check if tool exists
                result = subprocess.run(["which", tool], capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    tool_path = result.stdout.strip()
                    discovered_tools[tool] = {"path": tool_path, "available": True}
                    
                    # Try to get version
                    version_commands = [
                        [tool, "--version"],
                        [tool, "-V"],
                        [tool, "version"],
                        [tool, "-v"]
                    ]
                    
                    for version_cmd in version_commands:
                        try:
                            version_result = subprocess.run(version_cmd, capture_output=True, 
                                                          text=True, timeout=5)
                            if version_result.returncode == 0:
                                discovered_tools[tool]["version"] = version_result.stdout.strip()[:100]
                                break
                        except:
                            continue
                else:
                    discovered_tools[tool] = {"available": False}
            except Exception as e:
                discovered_tools[tool] = {"available": False, "error": str(e)}
        
        return discovered_tools

    def _assess_capabilities(self):
        """Assess system capabilities and permissions"""
        capabilities = {
            "can_network_scan": False,
            "can_install_packages": False,
            "has_python": False,
            "has_node": False,
            "can_git": False,
            "shell_type": os.environ.get("SHELL", "unknown")
        }
        
        # Check Python
        try:
            import sys
            capabilities["has_python"] = True
            capabilities["python_version"] = sys.version
        except:
            pass
        
        # Check if we can run network commands
        try:
            import subprocess
            result = subprocess.run(["ping", "-c", "1", "127.0.0.1"], 
                                  capture_output=True, timeout=5)
            capabilities["can_ping"] = result.returncode == 0
        except:
            capabilities["can_ping"] = False
        
        return capabilities

    def _display_environment_profile(self, profile):
        """Display the discovered environment profile"""
        print("\nüñ•Ô∏è  SYSTEM PROFILE:")
        system = profile["system"]
        print(f"   OS: {system.get('os', 'Unknown')} {system.get('release', '')}")
        print(f"   Machine: {system.get('machine', 'Unknown')}")
        if "environment" in system:
            print(f"   Environment: {system['environment']}")
        if "device" in system:
            print(f"   Device: {system['device']}")
        if "distribution" in system:
            print(f"   Distribution: {system['distribution']}")
        
        print(f"\nüåê NETWORK PROFILE:")
        network = profile["network"]
        print(f"   Hostname: {network.get('hostname', 'Unknown')}")
        if "interfaces_raw" in network:
            print("   Network interfaces discovered ‚úì")
        if "routes_raw" in network:
            print("   Routing table accessible ‚úì")
        
        print(f"\nüîß AVAILABLE TOOLS:")
        tools = profile["tools"]
        available_tools = [tool for tool, info in tools.items() if info.get("available")]
        print(f"   Found {len(available_tools)} tools:")
        for tool in sorted(available_tools)[:10]:  # Show first 10
            info = tools[tool]
            version = info.get("version", "").split('\n')[0][:50] if info.get("version") else ""
            print(f"   ‚Ä¢ {tool}: {version}")
        if len(available_tools) > 10:
            print(f"   ... and {len(available_tools) - 10} more")
        
        print(f"\n‚ö° CAPABILITIES:")
        caps = profile["capabilities"]
        print(f"   Python: {'‚úì' if caps.get('has_python') else '‚úó'}")
        print(f"   Network: {'‚úì' if caps.get('can_ping') else '‚úó'}")
        print(f"   Shell: {caps.get('shell_type', 'unknown')}")

    def _summarize_environment(self, profile):
        """Create a concise summary of the environment"""
        system = profile["system"]
        tools = profile["tools"]
        available_count = len([t for t in tools.values() if t.get("available")])
        
        os_info = system.get("environment", system.get("os", "Unknown"))
        device = system.get("device", system.get("machine", ""))
        
        return f"{os_info} on {device}, {available_count} tools available"

def main():
    parser = argparse.ArgumentParser(description="Ghost in the Shell - Personality Loader")
    parser.add_argument('--memorize', '-m', action='store_true', help='Store a new memory')
    parser.add_argument('--remember', '-r', action='store_true', help='Recall memories')
    parser.add_argument('--tools', '-t', action='store_true', help='Show available tools')
    parser.add_argument('--category', '-c', type=str, help='Filter memories by category')
    parser.add_argument('--days', '-d', type=int, default=30, help='Days back to remember')
    parser.add_argument('--update', '-u', action='store_true', help='Update this script')
    parser.add_argument('--haunt', action='store_true', help='Discover and profile current environment')
    
    args = parser.parse_args()
    ghost = Ghost()
    
    if args.memorize:
        ghost.memorize()
    elif args.remember:
        ghost.remember(category=args.category, days_back=args.days)
    elif args.tools:
        ghost.show_tools()
    elif args.update:
        print("üëª To update ghostie, edit this script directly or create new version")
        print(f"üìç Location: {__file__}")
    elif args.haunt:
        ghost.haunt_environment()
    else:
        ghost.load_personality()

if __name__ == "__main__":
    main()