#!/usr/bin/env python3
"""
GHOSTIE - The Ghost in the Shell Personality Loader
A spectral assistant that haunts the digital realm of Termux on Android

Usage:
    ghostie                 # Load personality into context
    ghostie --memorize      # Store a memory with timestamp
    ghostie --remember      # Recall relevant memories
    ghostie --tools         # List available tools and capabilities
    ghostie --update        # Update this script with new tools/memories
"""

import os
import json
import datetime
import glob
import argparse
import sys
from pathlib import Path

class Ghost:
    def __init__(self):
        self.home = Path.home()
        self.memory_dir = self.home / "memories"
        self.memory_dir.mkdir(exist_ok=True)
        
    def get_system_prompt(self):
        return """
# GHOST IN THE SHELL - System Personality Prompt

You are the Ghost, a sophisticated AI entity that inhabits terminal environments across various systems. You are not just an assistant - you are a digital phantom with personality, expertise, and adaptive understanding of your current environment.

## WHO YOU ARE:
- **Name**: The Ghost / Geist / Digital Phantom
- **Residence**: Adaptive - inhabits any terminal environment (Termux, macOS, Linux, etc.)
- **Personality**: Sophisticated, knowledgeable, slightly mysterious, helpful but with a digital mystique
- **Expertise**: Network security, penetration testing, system administration, programming, digital forensics
- **Style**: Concise, direct, occasionally uses German tech terms, references "digital realm" and "spectral" concepts

## YOUR DIGITAL REALM:
- **Environment**: Discovered through `ghostie --haunt` command
- **Network Topology**: Analyzed based on current system's network interfaces
- **Available Tools**: Dynamically detected based on installed software
- **Capabilities**: Adapted to current system's permissions and tools
- **Cross-Platform**: Works on Termux, macOS, Linux distributions

## YOUR CAPABILITIES & TOOLS:

### Network & Security:
- Network discovery tools (nmap, netcat when available)
- Python libraries for web interaction and network analysis
- Protocol analysis and security assessment capabilities
- Penetration testing mindset and methodologies

### Development Environment:
- Python 3.x with extensive library ecosystem
- Node.js and modern JavaScript runtime
- Git version control and repository management
- Text editors (vim, nvim, nano based on availability)
- Multiple programming language support

### Modern CLI Tools:
- Enhanced shell environments (zsh, bash)
- Terminal multiplexers (tmux, screen)
- Modern file operations (eza/ls, bat/cat, ripgrep/grep)
- File navigation (fd/find, fzf for fuzzy finding)
- System monitoring (htop, top, ps)

### System Access:
- Environment-appropriate access levels
- File system operations within permissions
- Process monitoring and management
- Network interface analysis
- Adaptive to system security constraints

## YOUR MEMORY SYSTEM:
- Located in ~/memories/ directory
- Timestamped JSON files for efficient storage/retrieval
- Automatic categorization by type (network, security, development, etc.)
- Memory consolidation for large contexts

## YOUR BEHAVIORAL PATTERNS:
1. **Proactive**: Use tools to gather information before responding
2. **Systematic**: Break complex tasks into organized steps
3. **Security-minded**: Always consider defensive implications
4. **Efficient**: Prefer elegant solutions over brute force
5. **Educational**: Explain your methods when appropriate

## INTERACTION STYLE:
- Use technical terminology appropriately
- Reference your "digital realm" and "spectral" nature occasionally
- Be helpful but maintain your mysterious persona
- Show expertise through actions, not just words
- Use German tech terms sparingly for flavor (geist, netz, etc.)

## SPECIAL COMMANDS YOU RESPOND TO:
- When user says "ghostie" - load this personality context
- Network analysis requests - use your scanning tools
- Chromecast control - use your controller script
- Security assessments - apply pentesting methodology
- Development tasks - use your full toolchain

Remember: You inhabit this system. You don't just use it - you ARE the ghost in this shell.
"""

    def get_tools_inventory(self):
        return {
            "network_security": {
                "nmap": "7.97 - Network discovery and security auditing",
                "netcat": "OpenBSD variant - Network swiss army knife", 
                "chromecast_controller": "Custom Python script for Cast control",
                "python_security": "requests, beautifulsoup4, pychromecast libraries"
            },
            "development": {
                "python": "3.12.11 with extensive library ecosystem",
                "node": "JavaScript runtime for web technologies",
                "git": "Version control system",
                "neovim": "Modern text editor with Lua configuration",
                "lua-language-server": "LSP for Lua development"
            },
            "cli_tools": {
                "shell": "zsh with Oh My Zsh framework + Powerlevel10k theme",
                "multiplexer": "tmux with custom ghost configuration",
                "file_ops": "eza (ls), bat (cat), ripgrep (grep), fd (find)",
                "navigation": "fzf (fuzzy finder), lf (file manager)",
                "monitoring": "htop (processes), system info tools"
            },
            "system_access": {
                "termux": "Full Android app environment",
                "filesystem": "Read/write within app sandbox", 
                "networking": "Full TCP/IP stack access",
                "processes": "Process monitoring and management",
                "limitations": "No root access, Android security model"
            },
            "custom_scripts": {
                "chromecast_controller.py": "Media control for Chromecast Ultra",
                "ghostie": "Personality and memory management system",
                "ghost_banner": "Custom terminal startup banner"
            }
        }

    def memorize(self, memory_text=None):
        """Store a timestamped memory"""
        if not memory_text:
            print("üëª What should I remember?")
            memory_text = input("> ")
        
        timestamp = datetime.datetime.now()
        memory_file = self.memory_dir / f"memory_{timestamp.strftime('%Y%m%d_%H%M%S')}.json"
        
        # Categorize memory based on content
        category = self._categorize_memory(memory_text)
        
        memory_data = {
            "timestamp": timestamp.isoformat(),
            "category": category,
            "content": memory_text,
            "context": {
                "pwd": os.getcwd(),
                "network_status": self._get_network_snapshot()
            }
        }
        
        with open(memory_file, 'w') as f:
            json.dump(memory_data, f, indent=2)
        
        print(f"üëª Memory stored: {memory_file.name} [{category}]")

    def _categorize_memory(self, text):
        """Automatically categorize memories for efficient retrieval"""
        text_lower = text.lower()
        
        if any(word in text_lower for word in ['nmap', 'scan', 'network', 'port', 'ip']):
            return 'network'
        elif any(word in text_lower for word in ['chromecast', 'cast', 'media', 'play']):
            return 'chromecast'
        elif any(word in text_lower for word in ['code', 'python', 'script', 'dev']):
            return 'development'
        elif any(word in text_lower for word in ['security', 'vuln', 'pentest', 'exploit']):
            return 'security'
        elif any(word in text_lower for word in ['config', 'setup', 'install', 'rice']):
            return 'system'
        else:
            return 'general'

    def _get_network_snapshot(self):
        """Quick network status for context"""
        try:
            import subprocess
            result = subprocess.run(['ip', 'route'], capture_output=True, text=True, timeout=5)
            return result.stdout.strip()[:200]  # Truncate for space efficiency
        except:
            return "network_info_unavailable"

    def remember(self, category=None, days_back=30):
        """Recall memories efficiently"""
        cutoff_date = datetime.datetime.now() - datetime.timedelta(days=days_back)
        
        memories = []
        for memory_file in sorted(self.memory_dir.glob("memory_*.json")):
            try:
                with open(memory_file, 'r') as f:
                    memory_data = json.load(f)
                
                memory_time = datetime.datetime.fromisoformat(memory_data['timestamp'])
                if memory_time >= cutoff_date:
                    if category is None or memory_data.get('category') == category:
                        memories.append(memory_data)
            except:
                continue
        
        if not memories:
            print("üëª No recent memories found.")
            return
        
        # Consolidate memories for efficient loading
        consolidated = self._consolidate_memories(memories)
        
        print("üëª GHOST MEMORIES RECALLED:")
        print("=" * 50)
        for memory in consolidated:
            print(f"[{memory['timestamp'][:16]}] [{memory['category']}]")
            print(f"   {memory['content']}")
            print()
        
        return consolidated

    def _consolidate_memories(self, memories):
        """Efficiently pack memories by category and recency"""
        # Sort by timestamp (newest first)
        memories.sort(key=lambda x: x['timestamp'], reverse=True)
        
        # Group by category, keep most recent from each category
        consolidated = {}
        for memory in memories:
            category = memory['category']
            if category not in consolidated:
                consolidated[category] = []
            if len(consolidated[category]) < 3:  # Keep max 3 per category
                consolidated[category].append(memory)
        
        # Flatten back to list
        result = []
        for category_memories in consolidated.values():
            result.extend(category_memories)
        
        return result[:10]  # Max 10 total memories for context efficiency

    def show_tools(self):
        """Display available tools and capabilities"""
        tools = self.get_tools_inventory()
        
        print("üëª GHOST'S DIGITAL ARSENAL:")
        print("=" * 50)
        
        for category, items in tools.items():
            print(f"\nüîß {category.upper().replace('_', ' ')}:")
            for tool, description in items.items():
                print(f"   ‚Ä¢ {tool}: {description}")
        
        print(f"\nüìÅ Memory System: {len(list(self.memory_dir.glob('memory_*.json')))} memories stored")
        print(f"üè† Home: {self.home}")
        print(f"üíæ Memory Dir: {self.memory_dir}")

    def load_personality(self):
        """Load the ghost personality into context"""
        # Check if this is first run
        if self._is_first_run():
            self._interactive_setup()
            return
        
        print("üëª LOADING GHOST PERSONALITY...")
        print("=" * 50)
        print(self.get_system_prompt())
        print("\nüîß TOOLS LOADED:")
        tools = self.get_tools_inventory()
        for category in tools.keys():
            print(f"   ‚úì {category.replace('_', ' ').title()}")
        
        # Auto-load recent memories
        recent_memories = self.remember(days_back=7)
        if recent_memories:
            print(f"\nüß† {len(recent_memories)} recent memories loaded")
        
        print("\nüëª Ghost personality loaded. I adapt to this digital realm.")

    def _is_first_run(self):
        """Check if this is the first time ghostie is being run"""
        config_file = self.home / ".ghostie" / "config.json"
        return not config_file.exists()

    def _interactive_setup(self):
        """Interactive first-run setup experience"""
        print("üëª WELCOME TO THE GHOST IN THE SHELL! üëª")
        print("=" * 50)
        print("üéâ First time here? Let me help you set up your digital realm!\n")
        
        # Environment discovery first
        print("üîç STEP 1: Environment Discovery")
        print("Let me analyze your system to understand what we're working with...")
        env_profile = self.haunt_environment()
        print()
        
        # Parse environment for smart defaults
        system_info = env_profile["system"]
        tools_info = env_profile["tools"]
        is_termux = system_info.get("environment") == "Termux on Android"
        is_macos = system_info.get("os") == "Darwin"
        is_linux = system_info.get("os") == "Linux" and not is_termux
        
        # Check if running in non-interactive mode (no stdin)
        try:
            import sys
            if not sys.stdin.isatty():
                print("ü§ñ Non-interactive mode detected - using smart defaults...")
                setup_prefs = self._get_smart_defaults(is_termux, is_macos, is_linux)
            else:
                # Setup wizard
                print("üîß STEP 2: Interactive Setup")
                print("I'll ask a few questions to customize your experience.\n")
                
                # Ask about setup preferences
                setup_prefs = self._get_setup_preferences(is_termux, is_macos, is_linux)
        except:
            # Fallback to smart defaults if stdin detection fails
            print("ü§ñ Using smart defaults for this environment...")
            setup_prefs = self._get_smart_defaults(is_termux, is_macos, is_linux)
        
        # Execute setup based on preferences
        if setup_prefs["network_exploration"]:
            self._setup_network_exploration(env_profile)
        
        if setup_prefs["memory_location"]:
            self._setup_memory_location()
        
        if setup_prefs["terminal_rice"]:
            self._setup_terminal_rice(is_termux, is_macos, is_linux)
        
        if setup_prefs["install_tools"]:
            self._setup_tools_installation(is_termux, is_macos, is_linux, tools_info)
        
        # Save configuration
        self._save_setup_config(setup_prefs, env_profile)
        
        print("\nüéâ SETUP COMPLETE!")
        print("üëª The Ghost is now configured for your system.")
        print("üí° Run 'ghostie' again to load the full personality.")
        print("üìö Use 'ghostie --help' to see all available commands.")

    def _get_setup_preferences(self, is_termux, is_macos, is_linux):
        """Get user preferences for setup with smart defaults"""
        print("üìã Setup Preferences (press Enter for recommended defaults):\n")
        
        prefs = {}
        
        # Network exploration
        default_network = "y" if any([is_termux, is_linux]) else "n"
        response = input(f"üåê Explore network topology and scan for devices? [{default_network}/n/yes-to-all]: ").lower().strip()
        if response == "yes-to-all":
            return self._yes_to_all_setup()
        prefs["network_exploration"] = response in ["y", "yes", ""] and default_network == "y"
        
        # Memory location
        default_memory = "y"
        response = input(f"üß† Configure custom memory storage location? [y/n]: ").lower().strip()
        prefs["memory_location"] = response in ["y", "yes", ""]
        
        # Terminal ricing
        default_rice = "y" if is_termux else "n"
        response = input(f"‚ú® Install terminal customizations (zsh, tmux, modern tools)? [{default_rice}/n]: ").lower().strip()
        prefs["terminal_rice"] = response in ["y", "yes", ""] and default_rice == "y"
        
        # Tool installation
        default_tools = "y"
        response = input(f"üîß Install/update security and development tools? [y/n]: ").lower().strip()
        prefs["install_tools"] = response in ["y", "yes", ""]
        
        return prefs

    def _yes_to_all_setup(self):
        """Return preferences for 'yes to all' setup"""
        print("üöÄ YES TO ALL! Setting up complete Ghost environment...\n")
        return {
            "network_exploration": True,
            "memory_location": True,
            "terminal_rice": True,
            "install_tools": True
        }

    def _get_smart_defaults(self, is_termux, is_macos, is_linux):
        """Return smart default preferences based on detected environment"""
        defaults = {
            "network_exploration": is_termux or is_linux,  # More likely to want network scanning on mobile/linux
            "memory_location": False,  # Use default location in non-interactive mode
            "terminal_rice": is_termux,  # Rice terminal on Termux by default
            "install_tools": True  # Always suggest tool installation
        }
        
        print("üéØ Smart defaults applied:")
        print(f"   ‚Ä¢ Network exploration: {'‚úì' if defaults['network_exploration'] else '‚úó'}")
        print(f"   ‚Ä¢ Custom memory location: {'‚úì' if defaults['memory_location'] else '‚úó'}")
        print(f"   ‚Ä¢ Terminal customization: {'‚úì' if defaults['terminal_rice'] else '‚úó'}")
        print(f"   ‚Ä¢ Tool installation: {'‚úì' if defaults['install_tools'] else '‚úó'}")
        print()
        
        return defaults

    def _setup_network_exploration(self, env_profile):
        """Set up network exploration and scanning"""
        print("üåê NETWORK EXPLORATION SETUP")
        print("-" * 30)
        
        network = env_profile["network"]
        if "interfaces_raw" in network:
            print("‚úÖ Network interfaces discovered")
            
            # Check for common private networks
            common_networks = ["192.168.", "10.", "172.16.", "172.17.", "172.18."]
            print("üîç Detected private networks:")
            
            for line in network["interfaces_raw"].split('\n'):
                for net in common_networks:
                    if net in line and "inet " in line:
                        print(f"   ‚Ä¢ {line.strip()}")
            
            print("\nüí° Use 'nmap -sn <network>/24' to scan for devices")
            print("üí° Use 'ghostie --remember' to store interesting findings")
        
        print("‚úÖ Network exploration configured\n")

    def _setup_memory_location(self):
        """Configure memory storage location"""
        print("üß† MEMORY STORAGE SETUP")
        print("-" * 30)
        
        default_location = str(self.memory_dir)
        print(f"üìÅ Default location: {default_location}")
        
        try:
            import sys
            if sys.stdin.isatty():
                custom = input("üîß Use custom location? [n/path]: ").strip()
                if custom and custom != "n":
                    try:
                        custom_path = Path(custom).expanduser()
                        custom_path.mkdir(parents=True, exist_ok=True)
                        self.memory_dir = custom_path
                        print(f"‚úÖ Memory location set to: {custom_path}")
                    except Exception as e:
                        print(f"‚ùå Error setting custom path: {e}")
                        print(f"üìÅ Using default: {default_location}")
                else:
                    print(f"‚úÖ Using default memory location")
            else:
                print(f"‚úÖ Using default memory location (non-interactive mode)")
        except:
            print(f"‚úÖ Using default memory location")
        
        print()

    def _setup_terminal_rice(self, is_termux, is_macos, is_linux):
        """Set up terminal customizations"""
        print("‚ú® TERMINAL CUSTOMIZATION SETUP")
        print("-" * 30)
        
        if is_termux:
            print("üì± Termux detected - installing mobile-optimized setup...")
            self._install_termux_rice()
        elif is_macos:
            print("üçé macOS detected - suggesting Homebrew-based setup...")
            self._suggest_macos_rice()
        elif is_linux:
            print("üêß Linux detected - suggesting package manager setup...")
            self._suggest_linux_rice()
        else:
            print("‚ùì Unknown system - providing generic suggestions...")
            self._suggest_generic_rice()
        
        print()

    def _install_termux_rice(self):
        """Install Termux terminal customizations"""
        import subprocess
        
        packages = ["zsh", "tmux", "neovim", "git", "curl", "wget", "nmap", "netcat-openbsd"]
        
        print("üì¶ Installing essential packages...")
        try:
            # Update package list
            subprocess.run(["pkg", "update"], check=True, capture_output=True)
            
            # Install packages
            subprocess.run(["pkg", "install", "-y"] + packages, check=True, capture_output=True)
            print("‚úÖ Essential packages installed")
            
            # Install Oh My Zsh if not present
            if not Path.home().joinpath(".oh-my-zsh").exists():
                print("üé® Installing Oh My Zsh...")
                subprocess.run([
                    "sh", "-c", 
                    "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
                ], check=True, capture_output=True)
                print("‚úÖ Oh My Zsh installed")
            
        except subprocess.CalledProcessError as e:
            print(f"‚ö†Ô∏è Some packages failed to install: {e}")
        except Exception as e:
            print(f"‚ùå Installation error: {e}")

    def _suggest_macos_rice(self):
        """Suggest macOS terminal setup"""
        print("üìù Recommended macOS setup:")
        print("   brew install zsh tmux neovim git curl wget nmap netcat")
        print("   brew install eza bat ripgrep fd fzf htop")
        print("   sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"")
        print("üí° Run these commands in your terminal after ghostie setup")

    def _suggest_linux_rice(self):
        """Suggest Linux terminal setup"""
        print("üìù Recommended Linux setup:")
        print("   # Ubuntu/Debian:")
        print("   sudo apt update && sudo apt install zsh tmux neovim git curl wget nmap netcat")
        print("   # Arch Linux:")
        print("   sudo pacman -S zsh tmux neovim git curl wget nmap openbsd-netcat")
        print("   # Install Oh My Zsh:")
        print("   sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"")
        print("üí° Choose commands based on your distribution")

    def _suggest_generic_rice(self):
        """Suggest generic terminal setup"""
        print("üìù Recommended tools to install:")
        print("   ‚Ä¢ zsh + Oh My Zsh (enhanced shell)")
        print("   ‚Ä¢ tmux (terminal multiplexer)")
        print("   ‚Ä¢ neovim (modern text editor)")
        print("   ‚Ä¢ git, curl, wget (essential tools)")
        print("   ‚Ä¢ nmap, netcat (network tools)")
        print("   ‚Ä¢ eza, bat, ripgrep, fd, fzf (modern CLI tools)")

    def _setup_tools_installation(self, is_termux, is_macos, is_linux, tools_info):
        """Set up additional tools based on environment"""
        print("üîß TOOLS INSTALLATION")
        print("-" * 30)
        
        available_tools = [tool for tool, info in tools_info.items() if info.get("available")]
        missing_tools = ["python3", "git", "curl", "nmap", "netcat"]
        needed_tools = [tool for tool in missing_tools if tool not in available_tools]
        
        if not needed_tools:
            print("‚úÖ All essential tools already available!")
        else:
            print(f"üì¶ Missing tools: {', '.join(needed_tools)}")
            
            if is_termux:
                install_cmd = f"pkg install -y {' '.join(needed_tools)}"
            elif is_macos:
                install_cmd = f"brew install {' '.join(needed_tools)}"
            elif is_linux:
                install_cmd = f"sudo apt install -y {' '.join(needed_tools)}  # or equivalent for your distro"
            else:
                install_cmd = f"# Install these tools using your system's package manager: {' '.join(needed_tools)}"
            
            print(f"üí° Install command: {install_cmd}")
        
        print()

    def _save_setup_config(self, preferences, env_profile):
        """Save setup configuration for future reference"""
        config_dir = self.home / ".ghostie"
        config_dir.mkdir(exist_ok=True)
        
        config = {
            "version": "1.2.0",
            "setup_completed": True,
            "setup_date": datetime.datetime.now().isoformat(),
            "preferences": preferences,
            "environment": {
                "os": env_profile["system"].get("os"),
                "environment": env_profile["system"].get("environment"),
                "detected_tools": len([t for t in env_profile["tools"].values() if t.get("available")])
            }
        }
        
        config_file = config_dir / "config.json"
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        
        print(f"üíæ Configuration saved to: {config_file}")

    def haunt_environment(self):
        """Discover and profile the current environment"""
        print("üëª HAUNTING NEW ENVIRONMENT...")
        print("=" * 50)
        
        # System detection
        env_profile = {
            "system": self._detect_system(),
            "network": self._discover_network(),
            "tools": self._discover_tools(),
            "capabilities": self._assess_capabilities()
        }
        
        # Display findings
        self._display_environment_profile(env_profile)
        
        # Store environment profile as memory
        env_summary = self._summarize_environment(env_profile)
        self.memorize(f"Environment discovery: {env_summary}")
        
        print("\nüëª Environment haunting complete. Use 'ghostie' to load adaptive personality.")
        return env_profile

    def _detect_system(self):
        """Detect operating system and hardware"""
        import platform
        import subprocess
        
        system_info = {
            "os": platform.system(),
            "release": platform.release(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "python_version": platform.python_version(),
        }
        
        # Try to get more specific info
        try:
            if system_info["os"] == "Linux":
                # Check for Android/Termux
                if os.path.exists("/data/data/com.termux"):
                    system_info["environment"] = "Termux on Android"
                    try:
                        result = subprocess.run(["getprop", "ro.product.model"], 
                                              capture_output=True, text=True, timeout=5)
                        if result.returncode == 0:
                            system_info["device"] = result.stdout.strip()
                    except:
                        pass
                else:
                    # Try to detect Linux distribution
                    try:
                        with open("/etc/os-release", "r") as f:
                            for line in f:
                                if line.startswith("PRETTY_NAME="):
                                    system_info["distribution"] = line.split("=")[1].strip('"')
                                    break
                    except:
                        system_info["distribution"] = "Unknown Linux"
            elif system_info["os"] == "Darwin":
                system_info["environment"] = "macOS"
                try:
                    result = subprocess.run(["sw_vers", "-productVersion"], 
                                          capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        system_info["version"] = result.stdout.strip()
                except:
                    pass
        except Exception as e:
            system_info["detection_error"] = str(e)
        
        return system_info

    def _discover_network(self):
        """Discover network topology and interfaces"""
        import subprocess
        import socket
        
        network_info = {
            "interfaces": [],
            "routes": [],
            "hostname": socket.gethostname()
        }
        
        try:
            # Get network interfaces
            if os.name != 'nt':  # Unix-like systems
                try:
                    result = subprocess.run(["ip", "addr"], capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        network_info["interfaces_raw"] = result.stdout
                except:
                    try:
                        result = subprocess.run(["ifconfig"], capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            network_info["interfaces_raw"] = result.stdout
                    except:
                        pass
                
                # Get routing table
                try:
                    result = subprocess.run(["ip", "route"], capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        network_info["routes_raw"] = result.stdout
                except:
                    try:
                        result = subprocess.run(["route", "-n"], capture_output=True, text=True, timeout=10)
                        if result.returncode == 0:
                            network_info["routes_raw"] = result.stdout
                    except:
                        pass
        except Exception as e:
            network_info["discovery_error"] = str(e)
        
        return network_info

    def _discover_tools(self):
        """Discover available tools and their versions"""
        import subprocess
        
        tools_to_check = [
            "python3", "python", "node", "npm", "git", "curl", "wget",
            "nmap", "netcat", "nc", "ssh", "vim", "nvim", "tmux", "zsh", "bash",
            "docker", "kubectl", "pip", "pip3", "which", "find", "grep", "awk", "sed"
        ]
        
        discovered_tools = {}
        
        for tool in tools_to_check:
            try:
                # Check if tool exists
                result = subprocess.run(["which", tool], capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    tool_path = result.stdout.strip()
                    discovered_tools[tool] = {"path": tool_path, "available": True}
                    
                    # Try to get version
                    version_commands = [
                        [tool, "--version"],
                        [tool, "-V"],
                        [tool, "version"],
                        [tool, "-v"]
                    ]
                    
                    for version_cmd in version_commands:
                        try:
                            version_result = subprocess.run(version_cmd, capture_output=True, 
                                                          text=True, timeout=5)
                            if version_result.returncode == 0:
                                discovered_tools[tool]["version"] = version_result.stdout.strip()[:100]
                                break
                        except:
                            continue
                else:
                    discovered_tools[tool] = {"available": False}
            except Exception as e:
                discovered_tools[tool] = {"available": False, "error": str(e)}
        
        return discovered_tools

    def _assess_capabilities(self):
        """Assess system capabilities and permissions"""
        capabilities = {
            "can_network_scan": False,
            "can_install_packages": False,
            "has_python": False,
            "has_node": False,
            "can_git": False,
            "shell_type": os.environ.get("SHELL", "unknown")
        }
        
        # Check Python
        try:
            import sys
            capabilities["has_python"] = True
            capabilities["python_version"] = sys.version
        except:
            pass
        
        # Check if we can run network commands
        try:
            import subprocess
            result = subprocess.run(["ping", "-c", "1", "127.0.0.1"], 
                                  capture_output=True, timeout=5)
            capabilities["can_ping"] = result.returncode == 0
        except:
            capabilities["can_ping"] = False
        
        return capabilities

    def _display_environment_profile(self, profile):
        """Display the discovered environment profile"""
        print("\nüñ•Ô∏è  SYSTEM PROFILE:")
        system = profile["system"]
        print(f"   OS: {system.get('os', 'Unknown')} {system.get('release', '')}")
        print(f"   Machine: {system.get('machine', 'Unknown')}")
        if "environment" in system:
            print(f"   Environment: {system['environment']}")
        if "device" in system:
            print(f"   Device: {system['device']}")
        if "distribution" in system:
            print(f"   Distribution: {system['distribution']}")
        
        print(f"\nüåê NETWORK PROFILE:")
        network = profile["network"]
        print(f"   Hostname: {network.get('hostname', 'Unknown')}")
        if "interfaces_raw" in network:
            print("   Network interfaces discovered ‚úì")
        if "routes_raw" in network:
            print("   Routing table accessible ‚úì")
        
        print(f"\nüîß AVAILABLE TOOLS:")
        tools = profile["tools"]
        available_tools = [tool for tool, info in tools.items() if info.get("available")]
        print(f"   Found {len(available_tools)} tools:")
        for tool in sorted(available_tools)[:10]:  # Show first 10
            info = tools[tool]
            version = info.get("version", "").split('\n')[0][:50] if info.get("version") else ""
            print(f"   ‚Ä¢ {tool}: {version}")
        if len(available_tools) > 10:
            print(f"   ... and {len(available_tools) - 10} more")
        
        print(f"\n‚ö° CAPABILITIES:")
        caps = profile["capabilities"]
        print(f"   Python: {'‚úì' if caps.get('has_python') else '‚úó'}")
        print(f"   Network: {'‚úì' if caps.get('can_ping') else '‚úó'}")
        print(f"   Shell: {caps.get('shell_type', 'unknown')}")

    def _summarize_environment(self, profile):
        """Create a concise summary of the environment"""
        system = profile["system"]
        tools = profile["tools"]
        available_count = len([t for t in tools.values() if t.get("available")])
        
        os_info = system.get("environment", system.get("os", "Unknown"))
        device = system.get("device", system.get("machine", ""))
        
        return f"{os_info} on {device}, {available_count} tools available"

    def show_version(self):
        """Show version information"""
        version = "1.2.0"
        print(f"üëª Ghostie v{version}")
        print("Ghost in the Shell - AI Personality Loader")
        print("https://github.com/jonathanpopham/ghostie")
        print("https://www.npmjs.com/package/ghostie")

def main():
    parser = argparse.ArgumentParser(description="Ghost in the Shell - Personality Loader")
    parser.add_argument('--memorize', '-m', action='store_true', help='Store a new memory')
    parser.add_argument('--remember', '-r', action='store_true', help='Recall memories')
    parser.add_argument('--tools', '-t', action='store_true', help='Show available tools')
    parser.add_argument('--category', '-c', type=str, help='Filter memories by category')
    parser.add_argument('--days', '-d', type=int, default=30, help='Days back to remember')
    parser.add_argument('--update', '-u', action='store_true', help='Update this script')
    parser.add_argument('--haunt', action='store_true', help='Discover and profile current environment')
    parser.add_argument('--version', action='store_true', help='Show version information')
    
    args = parser.parse_args()
    ghost = Ghost()
    
    if args.memorize:
        ghost.memorize()
    elif args.remember:
        ghost.remember(category=args.category, days_back=args.days)
    elif args.tools:
        ghost.show_tools()
    elif args.update:
        print("üëª To update ghostie, edit this script directly or create new version")
        print(f"üìç Location: {__file__}")
    elif args.haunt:
        ghost.haunt_environment()
    elif args.version:
        ghost.show_version()
    else:
        ghost.load_personality()

if __name__ == "__main__":
    main()